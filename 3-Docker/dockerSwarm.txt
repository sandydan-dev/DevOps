# Docker Swarm

# If we want to manage multiple containers on multiple machines, than we use "Docker Swarm".
                              (server/manager/leader)
                          +---------------------------+
                          |     MANAGER NODE (Leader) |
                          |---------------------------|
                          |  â€¢ Orchestrates Swarm     |
                          |  â€¢ Deploys Services       |
                          |  â€¢ Monitors Health        |
                          +-------------+-------------+
                                        |
                                        |
                  -------------------------------------------------
                  |                        |                        |
      +--------------------+    +--------------------+    +--------------------+
      |  WORKER NODE 1     |    |  WORKER NODE 2     |    |  WORKER NODE 3     |
      |--------------------|    |--------------------|    |--------------------|
      |  Machine: swarm-w1 |    |  Machine: swarm-w2 |    |  Machine: swarm-w3 |
      |                    |    |                    |    |                    |
      |  +--------------+  |    |  +--------------+  |    |  +--------------+  |
      |  | Container:   |  |    |  | Container:   |  |    |  | Container:   |  |
      |  | web_service  |  |    |  | api_service  |  |    |  | db_service   |  |
      |  +--------------+  |    |  +--------------+  |    |  +--------------+  |
      |  +--------------+  |    |  +--------------+  |    |  +--------------+  |
      |  | Container:   |  |    |  | Container:   |  |    |  | Container:   |  |
      |  | cache_redis  |  |    |  | worker_app   |  |    |  | logger_app   |  |
      |  +--------------+  |    |  +--------------+  |    |  +--------------+  |
      +--------------------+    +--------------------+    +--------------------+

                             <=== Overlay Network ===>
                        (Allows containers to communicate across nodes)



# Manager Node: controls and manages the entire swarm (creates service, deploy tasks, monitor status).

# Worker Node: run containers (the actual tasks).

# Overlay Network: allow all containers across machine to communicate seamlessly. 


> It means server is main part of swarm orchestration, which manage clients/nodes by giving command to server.
> Auto management of containers.
> If some container crash, it will create automatically in place of (healing container, we can scale or descrease container).
> vesioning means roll back

# cluster means, Group of multiple things called 'cluster'

# Go to AWS, create instace
> create 4 instance, and name them like
- 1 : leader/manager/server
- 2 : Node-1
- 3 : Node-2
- 4 : Node-3

> and add extra group port 2377 for all instance (docker swarm) 
- Port 2377/tcp : used for Docker Swarm cluster management communication (only between swarm manager and workers).


# Run all instance in the MobaXterm
> after run all instances, and install package in all instance
> apt update -y
> apt install git -y
> apt install docker.io -y

# Docker Swarm is a built in tool, and it is in disable mode, we have to enable docker swarm 
> check into , is docker swarm is there or not 
cmd: docker info | grep -i swarm 
result: it will show Swarm : Inactive

> so then initialize docke swarm in master only to handle other containers, only make master instance as Leader
cmd: docker swarm init      # run this cmd only on master/leader/server  

> after initialize it generate a token like this, take this token and paste into other nodes/workers
  which can handle node by master-node, no need to go inside other instances(nodes), 
  it will handle by only master.
docker swarm join --token SWMTKN-1-4mybgc1knrtgsda69beyrl8u34we4lizn0l3h7eu7g0mwz3ig0-5wxy82ccso1h1jzwm1lj5u6p7 172.31.0.95:2377

> see if docker swarm is activate
cmd: docker info | grep -i swarm  
result : Swarm : active

# To see how many machines are connected to master/leader, (check only on master)
cmd: docker node ls       # it will show connected nodes to master only 
- it show * this symbol as Master/Leader 


# There are two way to manage containers 
1 : Imperative way  
>  By running cmds we manage containers (infrastructure)

2 : Declarative way
> By creating file/script, writing script or code, with that you are managing containers, called Declarative.

> we have to define service based on that service manager will execute task in nodes.

# by cmd we create docker service and run nginx server with port mapping
cmd: docker service create -p 80:80 --name web nginx   # this create a container,port, and pull image nginx

> you can see image 
cmd: docker images    # it will show nginx image 

> to verify docker Services
cmd: docker service ls
- it shows service data image and replicas 1/1 and port *80:80->tcp

# pass instruction to manager and 
  manager can manage all other workers by cmd

> master instance will create a task 
> By default it create a 1 task, it execute task 

> to see what service are created by cmd
cmd: docker service ls
cmd: docker service ps web 

# we can increate/scale tasks, which task created by only master/leader
cmd: docker service scale web=3   # it will create 2 more task 

> to verify how many services/tasks are scaled by above cmd
cmd: docker service ps web      # web is a container name, it will generate container name like web.1, web.2, web.3 named like this.

> Master/Leader instance willdecide automatic where to create task(containerss)

> after scaling task see manager  creating task in other different worker(nodes) list

cmd: docker service ps web 
- it shows list of node where created task in different nodes 


# see there nodes private IP and match with aws Instance and take that aws instace public IP which assigned nodes
# take public IP and paste into browser < publicIP:80 >

# Get more information about services
cmd: docker service inspect --pretty web 

# Get info about perticular container 
cmd: docer inspect <container_id>

# update task/service, run the cmd to update all tasks and stop old containers and create new containers/tasks
cmd: docker service update --force web   # web is container name

# Docker service "Stand by (leader)"
> if main leader are absent or down, so we can make stand by leader ot handle other workers
> which means is main leader is abesent or not present or goes down so we can make leader to other node
> we can promote any node as a stand by leader.
- like : 
  *leader = leader
- stand by leaded : reachable  : it will indicate "stand by" as a leader

# see node list
cmd: docker node ls    # it will show working nodes

# to promote a node as a stand by leader
cmd: docker node promote <root:ip>
cmd: docker node promote ip-172-31-3-195   # this node-private-ip id promoted as stand by leader (reachable)

- after promoting node, see list status which is stand by leader shows like (reachagable) 
  ( MANAGER STATUS : reachable )

cmd: docker node ls


# create service with replicas in reachable leader
cmd: docker service create --replicas 4 -p 81:80 --name webserver nginx  # create container with nginx server

# Docker swarm "Drain" mode
- Remove workloads from a node safely without breaking the system.
- Existing tasks running on it will be stopped and moved to other active nodes.
- if you put a worker node in drain, it wont run container on that IP, its task moves to another node.

# To active drain mode 
cmd: docker node update --availability acitve <node-name or node-id>
cmd: docker node update --availability active < node-id >

# To deactivate drain mode
cmd: docker node update --availability pause <node-id> 

. by default drain mode is active


# Rollback 
- rollback: swarm will undo the update and bring the service back to its previous working version/configuration automatically 

- Example: 
       - you have a service running image nginx:v1
       - you update it to nginx:v2
       - if task fail or you manually rollbac, swarm redeploys the service with the old v1 image/config 

    - cmd: docker service update --image nginx:v1 web 

       - nginx image will update version and also update containers old containers stop and new container will create. 
       - it is a rollback update

       - if we want to rollback to preivous image version 
    - cmd: docker service update --rollback web

       - go inside container make some changes
       
       - to see docker service list
    - cmd: docker service ls     # see containers list
       
       - show task for that service (replicas runs)
    - cmd: docker service ps <server_name>      # service : web / webserver

       - see containers list
    - cmd: docker ps

       - go inside container
     - cmd: docker exec -it <container_id> bash or sh 


# Global node
- when we create a service, by default it gives 1 node 
- and we replicated a service, and leader will decide to place task in different node automatically

- if we use Global node, it means every node/worker will get each 1 task including leader 

- cmd: docker service create -p 80:80 --name web --mode global nginx 
- when run this cmd in global mode it will get every node a single task
- and each container listen  on port 80 of its host machine



# Delete a single service
> this stop and removes all running containers(replicas) for that on every node. 
- cmd: docker service rm <service_name>
       docker service rm web 

# Delete multiple service at a time
> removes several service at once. 
- cmd: docker service rm web werbserver db api 

# Remove specific container
cmd: docker rm -f <container_id>


# Docker Swarm (Declarative) way
- create a yaml file, write some script/code based on we goiing to manage containers 

- so we use docker-compose.yml file to manage container, so we deal with "declarative" node

- create file 
cmd : vi docker-compose.yml 
     ---           # this is optional for separate yml script in one file 
     version: "3.5"
     services:
       demoweb:
         image: nginx
           ports:
             - "80:80"
           volumes:
             - /tmp:/usr/share/nginx/html
             deploy:
             mode: replicated
               replicas: 3
 
 :wq!     # exit from file


# Nginx default file for working with web content
> /tmp    >  /user/share/nginx/html 

# docker stack
> whenever we manage compose in declarative mode, so "stack" will compose
> "stack" is a collection of services 


ðŸ³ Docker Stack Flow (Stack â†’ Services â†’ Tasks)

                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚        ðŸ³ Docker Stack        â”‚
                 â”‚           demoapp             â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚         Services            â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚                                     â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Service: webapp   â”‚               â”‚  Service: backend   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                                     â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                 â”‚                   â”‚                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task 1     â”‚   â”‚ Task 2     â”‚       â”‚ Task 1     â”‚   â”‚ Task 2     â”‚
â”‚ (worker1)  â”‚   â”‚ (worker2)  â”‚       â”‚ (manager)  â”‚   â”‚ (worker3)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜



# when we use docker-compose.yml in swarm in declarative mode script/code, so stack will come 

> stack is a collection of groups
> services is a collection task/containers â†’ Logical components inside the stack (e.g., webapp, backend).
> Tasks â†’ Individual running instances (replicas) of a service.
> Containers â†’ The actual runtime units of the tasks â€” each task = one container.


# so in compose file have 1 service and replicas is 2, so it create 2 task extra, total 3 tasks in service

> while working with compose file, we use cmd in swarm, use "docker stack" instead of "docker service"

cmd: docker stack deploy -c docker-compose.yml web   # this 
- create all services defined in the compose file.

cmd: docker stack ls    # list all deployed stack 

cmd: docker stack rm <service_name>   # removes a stack (stop all its containers)

cmd: docker stack ps <service_name>   # show tasks (containers) running in the stack

cmd: docker stack services web        # Shows all services inside the web stack.












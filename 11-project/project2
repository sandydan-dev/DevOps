# AMI : Amazon Linux
DevOps CI-CD Pipeline Project 2
This project demonstrates a CI-CD pipeline using AWS services.
# Project Structure:
Instance(git-server) > git hub > Instance (jenkins-server) - (git, java, maven, jenkins (job)) > instance (tomcat-server) - (java, tomcat)

┌───────────────┐ → ┌──────────┐ → ┌─────────────────────┐ → ┌─────────────────┐
│ Git Server    │   │ GitHub   │   │ Jenkins Server (EC2) │   │ Tomcat Server   │
│ (EC2, Git)    │   │ Repo     │   │ Git | Java | Maven   │   │ Java | Tomcat   │
└───────────────┘   └──────────┘   │ Jenkins Jobs         │   │ Deploy WAR      │
                                   └─────────────────────┘   └─────────────────┘
# Workflow:
1. Code is pushed to the GitHub repository.   # from git-server instance
2. Jenkins server pulls the latest code from GitHub.   # from jenkins-server instance
3. Jenkins builds the project using Maven.             # from jenkins-server instance
4. The built WAR file is deployed to the Tomcat server. # from jenkins-server instance to tomcat-server instance
5. Monitor the Jenkins jobs for build status and logs.

# Prerequisites:
- AWS EC2 instances for Git server, Jenkins server, and Tomcat server.
- Git installed on the Git server.
- Java and Maven installed on the Jenkins server.
- Jenkins installed and configured on the Jenkins server.
- Java and Tomcat installed on the Tomcat server.

# Jenkins Job Configuration with internal settings:
- Source Code Management:
  - Git Repository URL: [Your GitHub Repo URL]
  - Credentials: [Your GitHub Credentials]
- Build Triggers:
  - Poll SCM: H/5 * * * *
- Build Environment:
    - Delete workspace before build starts
- Build Steps:
    - Invoke top-level Maven targets:
        - Goals: clean install
- Post-build Actions:
    - Deploy WAR/EAR to a container:
        - WAR/EAR files: target/your-app.war
        - Context path: /your-app
        - Containers: Tomcat 7.x Remote
        - Tomcat URL: http://[Tomcat-Server-IP]:8080/
        - Credentials: [Your Tomcat Credentials]

# Note:
- Ensure all necessary ports (e.g., 8080 for Tomcat, 8080 for Jenkins) are open in the security groups of the respective EC2 instances.
- Adjust configurations based on your specific project requirements.    
- Regularly monitor the Jenkins jobs for build status and logs.
- Implement proper security measures for accessing GitHub, Jenkins, and Tomcat servers.
# Conclusion:
This project provides a foundational CI-CD pipeline setup using AWS EC2 instances and popular tools like Git, Jenkins, Maven, and Tomcat. It can be further enhanced with additional features like automated testing, notifications, and scaling based on project needs.
# AMI : Amazon Linux 
# End of Project Documentation

# ==================================================================================


# todo> Class: DevOps CI-CD Pipeline Project 2
# Description: This class represents the DevOps CI-CD Pipeline Project 2 documentation.

# Project Structure:
Instance(git-server) > git hub > Instance (jenkins-server) - (git, java, maven, jenkins (job)) > instance (tomcat-server) - (java, tomcat)  

┌───────────────┐ → ┌──────────┐ → ┌─────────────────────┐ → ┌─────────────────┐
│ Git Server    │   │ GitHub   │   │ Jenkins Server (EC2) │   │ Tomcat Server   │
│ (EC2, Git)    │   │ Repo     │   │ Git | Java | Maven   │   │ Java | Tomcat   │
└───────────────┘   └──────────┘   │ Jenkins Jobs         │   │ Deploy WAR      │
                                   └─────────────────────┘   └─────────────────┘

#todo: Workflow:
# Launch EC2 instances for Git server(Developer), Jenkins server(DevOps), and Tomcat server(DevOps). Install each tool in respective instances.

# 1. Code is pushed to the GitHub repository.
# 2. Jenkins server pulls the latest code from GitHub.
# 3. Jenkins builds the project using Maven.
# 4. The built WAR file is deployed to the Tomcat server,and see the application running in browser.
# 5: Monitor the Jenkins jobs for build status and logs.
# ==================================================================================

#todo: Step 1: Launch Git Server Instance
  - create/launch instance named : git-server
  - AMI : Amazon Linux
  - Instance Type: t2.medium
  - Security Group: Allow SSH (22) or All traffic , optional: HTTP (80), ( optional Git (9418) no used in this project)
  - Key Pair: dev-project.pem  # (make common key pair for all instances in this project)
  - Security group name: projectSG # (make common security group for all instances in this project)
  - Tag: Name : git-server
  - Configure storage : 8 GB, General Purpose SSD (gp2)

  - User data - optional:
    #!/bin/bash
    yum update -y
    yum install git -y
    yum install httpd -y
    cd /var/www/html
    echo "Git server is ready" > index.html
    service httpd start
    chkconfig httpd on
    # End of user data
  Launch Instance

# then login to git-server using ssh   (MobaXterm)
   - SSH :      ec2-user@[git-server-public-ip]
   - .pem file: dev-project.pem
   - ok

# then go as root user
   - cmd: sudo su -
   > now change the hostname, go inside /etc/hostname file and change the hostname to git-server
   - cmd: vi /etc/hostname
   - change the hostname to git-server
    - cmd: init 6  # reboot instance to reflect hostname change
    - after reboot login again using ssh
   - SSH :      ec2-user@[git-server-public-ip]
    - .pem file: dev-project.pem
    - ok
    - cmd: sudo su -
    - now check the hostname
     - cmd: hostname
        - output: [root@git-server ~]# hostname
                  git-server

    - now create a sample git repository
     - cmd: mkdir my-sample-repo.git
     - cmd: cd my-sample-repo.git
     - cmd: git init --bare  # create bare repository
     - now the git server is ready with a sample bare repository
     - end of git-server setup
# --------------  OR ----------------- #
    - or pull code from github repo to git-server (optional)
      - cmd: yum install git -y
      > name and email config (only first time)
      - cmd: git config --global user.name "sandeep"
        - cmd: git config --global user.email "sandydan.dev@gmail.com"
        - cmd: git clone [your-github-repo-url]
      
      - end of git-server setup

      - now verify git config
       - cmd: git config --list
        - output: user.name=sandeep
        - output: user.email=sandydan.dev@gmail.com
       - means git is working fine  

# now after pulling code from github 
    - got inside the cloned repo directory
     - cmd: cd FormFillApp          # [your-cloned-repo-directory]    
     (main file is |"pom.xml"| for maven build, webapp folder for web content to deploy in tomcat server) 
# ==================================================================================               

#todo: Step 2: Launch Jenkins Server Instance
-  create/launch instance named : jenkins-server
- we setup for Git, Java, Maven, In jenkins-server instance
- AMI : Amazon Linux
- Instance Type: t2.medium
- Security Group: use common security group : projectSG
    - Allow SSH (22)
    - Allow HTTP (80)  # optional
    - Allow Jenkins (8080) # this port is default jenkins port for web access
    - optional: Allow All traffic (not recommended for production)

- Key Pair: dev-project.pem  # (make common key pair for all instances in this project)
- Security group name: projectSG # (make common security group for all instances in this project)
- Configure storage : 25 GB, General Purpose SSD (gp2)
 Launch Instance

#! dont forget to add "Elastic Ip" for jenkins-server instance to avoid ip change after stop/start instance from aws console
- Allocate new Elastic IP from AWS console
- then Associate Elastic IP to jenkins-server instance
- now use this Elastic IP to access jenkins-server instance in browser
- http://[jenkins-server-elastic-ip]:8080/  # access jenkins server in browser like this, use this elastic ip everywhere instead of public ip 
- paste jenkins server url in browser to access jenkins server
- like : http://[jenkins-server-elastic-ip]:8080/
- now get the initial admin password from jenkins-server instance to unlock jenkins server in browser
- do not choose default plugins, choose "Install suggested plugins" option
- then create first admin user for jenkins server
- finally jenkins is ready to use


# then login to jenkins-server using ssh   (MobaXterm)
   - SSH :      ec2-user@[jenkins-server-public-ip]
    - .pem file: dev-project.pem
    - ok
# then go as root user
   - cmd: sudo su -
    > now change the hostname, go inside /etc/hostname file and change the hostname to jenkins-server
    - cmd: vi /etc/hostname
    - change the hostname to jenkins-server
     - cmd: init 6  # reboot instance to reflect hostname change
     - after reboot login again using ssh
    - SSH :      ec2-user@[jenkins-server-public-ip]
     - .pem file: dev-project.pem
     - ok
     - cmd: sudo su -
     - now check the hostname
      - cmd: hostname
        - output: [root@jenkins-server ~]# hostname
                  jenkins-server

# after all of this things install git, java, maven, jenkins in jenkins-server instance
# Install Git
 - cmd: yum install git -y
 - cmd: git --version   # verify git installation

# Install java-21*
 - cmd: yum install java-21* -y
 - cmd: java -version   # verify java installation

# Install Maven
- download maven: go to maven site > go to download section > copy the link of apache-maven-3.9.6-bin.tar.gz (latest version)
 - cmd: cd /opt   # why /opt ? because we install maven in /opt directory, its a good practice
 - cmd: wget https://downloads.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz
 - cmd: tar -xvzf apache-maven-3.9.6-bin.tar.gz   # extract the downloaded maven tar file
 - cmd: mv apache-maven-3.9.6 maven               # rename the extracted maven folder to maven
  
 - cd maven     # go inside maven directory to verify
 - cmd: pwd     # print working directory
   - output: /opt/maven   # this is for add in .bash_profile file for maven environment variables
    > also see file maven/bin to add in PATH variable
    like : M2: /opt/maven/bin and  M2_HOME : /opt/maven
- GO as root 
- cmd: cd      

> and nwo find the java path for environment variables
- cmd: readlink -f $(which java) 
  - output: /usr/lib/jvm/java-21-amazon-corretto.x86_64/bin/java
  or
  - cmd: find /usr/lib/jvm/java-21* | head -n 3 # to find java installation path
    - output: /usr/lib/jvm/java-21-amazon-corretto.x86_64 # this is the java home path

> choose /usr/lib/jvm/java-21-amazon-corretto.x86_64 as JAVA_HOME path for environment variables

- now open .bash_profile file to add environment variables for java and maven
  - cmd: vi .bash_profile     ( use this only)
   - now add below environment variables at the end of file
    JAVA_HOME=/usr/lib/jvm/java-21-amazon-corretto.x86_64
    M2=/opt/maven/bin     # maven bin path
    M2_HOME=/opt/maven    # maven home path
    PATH=$PATH:$HOME/bin:$JAVA_HOME:$M2:$M2_HOME  # add java and maven to PATH variable
    export PATH            # export PATH variable
   - now save and exit the file
   # or
    export JAVA_HOME=/usr/lib/jvm/java-21-amazon-corretto.x86_64
    export M2_HOME=/opt/maven
    export M2=$M2_HOME/bin
    export PATH=$JAVA_HOME/bin:$M2:$PATH
    - save and exit the file

- now reload or exit from root uesr, then again go as root user to reflect environment variables
 - cmd: exit    # exit from root user
 - cmd: sudo su -   # go again as root user
 - cmd: source .bash_profile   # reload the .bash_profile file to reflect environment variables

- now verify ENV variables for java and maven
 - cmd: echo $JAVA_HOME
   - output: /usr/lib/jvm/java-21-amazon-corretto.x86_64
 - cmd: echo $M2_HOME
   - output: /opt/maven
 - cmd: mvn -version
   - output: Apache Maven 3.9.6  # means maven is working fine
 - echo $PATH
   - output: ...:/usr/lib/jvm/java-21-amazon-corretto.x86_64/bin:/opt/maven/bin:...  # means PATH variable is set properly

- so now we configured git, java, maven in jenkins-server instance

- now install jenkins in jenkins-server instance
- cmd: wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
- cmd: rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
- cmd: yum install jenkins -y
- cmd: systemctl start jenkins  # start jenkins service
- cmd: systemctl enable jenkins # enable jenkins service, so that jenkins starts automatically after reboot
- cmd: systemctl status jenkins # verify jenkins service status
  - output: active (running)  # means jenkins service is running


# then access jenkins server in browser using public ip or elastic ip
- http://[jenkins-server-elastic-ip]:8080/  # access jenkins server in browser like this, use this elastic ip everywhere instead of public ip
- paste jenkins server url in browser to access jenkins server

- now take initial admin password from jenkins-server instance to unlock jenkins server in browser
- cmd: cat /var/lib/jenkins/secrets/initialAdminPassword     # copy this password
  - output:  abcd1234efgh5678ijkl9012mnop3456  # example password
- paste the password in browser to unlock jenkins server
- now choose "Install suggested plugins" option
- then create first admin user for jenkins server
- finally jenkins is ready to use and jenkins server link is http://13.49.124.248:8080/  # example link

- jenkins configuration is done in jenkins-server instance

- now install jenkins plugins required for this project
- Github plugin                # to integrate github with jenkins
- Maven Integration plugin     # to build maven projects in jenkins
- Deploy to container plugin   # to deploy war file to tomcat server from jenkins
- Publish OverSSH plugin       # to transfer files over ssh from jenkins to tomcat server (one machine to another machine)
> below optional plugins also install if required
- (below optional)
- Credentials plugin           # to manage credentials in jenkins
- SSH Credentials plugin       # to manage ssh credentials in jenkins
- etc

> Now got to manage jenkins > tools and configure system configuration for maven and jdk
- go to Manage Jenkins > Tool   ( under this section) 

- JDK installation
    - Add JDK
    - Name: java-21
    - JAVA_HOME: /usr/lib/jvm/java-21-amazon-corretto.x86_64 # inside jenkins-server instance
    - uncheck "Install automatically" option

- Git installation
    - Add Git
    - Name: git
    - Path to Git executable: /usr/bin/git  # inside jenkins-server instance
    - uncheck "Install automatically" option

- Maven installation
    - Add Maven
    - Name: maven-3.9.6
    - MAVEN_HOME: /opt/maven  # inside jenkins-server instance
    - uncheck "Install automatically" option
    
- nwo "apply + save" the configuration
- now jenkins-server is ready with git, java, maven, jenkins setup

# now create a jenkins job to implement CI-CD pipeline
> go to jenkins dashboard
- click on "New Item"
- enter item name: FormFillApp-CI-CD-Pipeline
- choose "maven project" option
- click OK
- now configure the jenkins job with below settings
- Source Code Management:
  - Git Repository URL: [Your GitHub Repo URL]
  - Credentials: [Your GitHub Credentials]
- Build Triggers:
  - Poll SCM: H/5 * * * *
  - Goal and options: clean install    # maven build command, means clean old build and do fresh build
  
- Post-build Actions:    #optional : (deploy war to tomcat server)
    - Deploy WAR/EAR to a container:
        - WAR/EAR files: target/FormFillApp.war
        - Context path: /FormFillApp
        - Containers: Tomcat 7.x Remote
        - Tomcat URL: http://[Tomcat-Server-IP]:8080/
        - Credentials: [Your Tomcat Credentials]
- now save the jenkins job configuration

- nwo build job manually first time
- click on "Build Now" option
- monitor the build console output for build status
- after build complete see the war file tomcat server also in jenkins files
- go inside :
   - cmd: cd /var/lib/jenkins/workspace/FormFillApp-CI-CD-Pipeline/target/<warfile>.war

- now see actual time and date for war file created
   - cmd: ls -l <warfile>.war
     - output: -rw-r--r-- 1 jenkins jenkins 123456 Jul 20 12:34 FormFillApp.war  # example output
# ==================================================================================

# start Step 3: Launch Tomcat Server Instance
# create/launch instance named : tomcat-server
- we setup for Java, Tomcat in tomcat-server instance # java is prerequisite for tomcat
- AMI : Amazon Linux
- Instance Type: t3.micro
- Security Group: use common security group : projectSG
    - Allow SSH (22)
    - Allow HTTP (80)  # optional
    - Allow Tomcat (8080) # this port is default tomcat port for web access
    - optional: Allow All traffic (not recommended for production)
- Key Pair: dev-project.pem  # (make common key pair for all instances in this project)
- Security group name: projectSG # (make common security group for all instances in this project)
- Configure storage : 8 GB, General Purpose SSD (gp2)
  Launch Instance

#! dont forget to add "Elastic Ip" for tomcat-server instance to avoid ip change after stop/start instance from aws console

- Allocate new Elastic IP from AWS console
- then Associate Elastic IP to tomcat-server instance
- now use this Elastic IP to access tomcat-server instance in browser
- http://[tomcat-server-elastic-ip]:8080/  # access tomcat server in browser like this, use this elastic ip everywhere instead of public ip
- paste tomcat server url in browser to access tomcat server in browser
- now login to tomcat-server using ssh   (MobaXterm)
   - SSH :      ec2-user@[tomcat-server-public-ip]
    - .pem file: dev-project.pem
    - ok
# then go as root user
   - cmd: sudo su -
    > now change the hostname, go inside /etc/hostname file and change the hostname to tomcat-server
    - cmd: vi /etc/hostname
    - change the hostname to tomcat-server
     - cmd: init 6  # reboot instance to reflect hostname change
     - after reboot login again using ssh
    - SSH :      ec2-user@[tomcat-server-public-ip]
     - .pem file: dev-project.pem
     - ok
     - cmd: sudo su -
     - now check the hostname
      - cmd: hostname
        - output: [root@tomcat-server ~]# hostname
                  tomcat-server
# after all of this things install java, tomcat in tomcat-server instance
# Install java-21*
 - cmd: yum install java-21* -y
 - cmd: java -version   # verify java installation

# Install Tomcat 9
 - cmd: cd /opt   # why /opt ? because we install tomcat in / opt directory, its a good practice
  - cmd: wget https://downloads.apache.org/tomcat/tomcat-9/v9.0.78/bin/apache-tomcat-9.0.78.tar.gz
  - cmd: tar -xvzf apache-tomcat-9.0.78.tar.gz   # extract the downloaded tomcat tar file
  - cmd: mv apache-tomcat-9.0.78 tomcat               # rename the extracted tomcat folder to tomcat9
  - cd tomcat     # go inside tomcat9 directory to verify
  - cmd: pwd     # print working directory
   - output: /opt/tomcat   # this is tomcat installation directory
  - now give execute permission to tomcat scripts present inside /opt/tomcat/bin directory

# now start tomcat server
  - cmd: cd /opt/tomcat/bin
  - cmd: ./startup.sh   # start tomcat server
  - now access tomcat server in browser
    - http://[tomcat-server-elastic-ip]:8080/  # access tomcat server in browser like this
  - now tomcat server is running

- But tomcat manager and host manager apps are not accessible right now, to access these apps we need to create tomcat users with roles in tomcat configuration file

- first find context.xml file  of managers app 

- cmd: find / -name context.xml 
  - output: /opt/tomcat/webapps/manager/META-INF/context.xml
            /opt/tomcat/webapps/host-manager/META-INF/context.xml # both files are same, but we need to edit both files

- now edit "/opt/tomcat/webapps/host-manager/META-INF/context.xml" file to allow access from all ip address
- cmd: vi /opt/tomcat/webapps/host-manager/META-INF/context.xml
  - now change the lines, cause it restricting access app to localhost only
   - change from
  <Valve className="org.apache.catalina.valves.RemoteCIDRValve"
         allow="127.0.0.0/8,::1/128" />
    - to >>>>
   - just comment this line, so that it allows access from all ip address
   <!-- <Valve className="org.apache.catalina.valves.RemoteCIDRValve" 
         allow="" /> -->
  - now save and exit the file

- now do the same for manager app also
- cmd: vi /opt/tomcat/webapps/manager/META-INF/context.xml
  - now change the lines, cause it restricting access app to localhost only
   - change from
  <Valve className="org.apache.catalina.valves.RemoteCIDRValve"
         allow="" />
    - to >>>>
    - just comment this line, so that it allows access from all ip address
    <!-- <Valve className="org.apache.catalina.valves.RemoteCIDRValve" 
          allow="" /> -->
  - now save and exit the file

- after modifying both context.xml file, we need to stop and start the tomcat server to reflect the changes
 - cmd: cd /opt/tomcat/bin
 - cmd: ./shutdown.sh   # stop tomcat server
 - cmd: ./startup.sh    # start tomcat server

 - now it asking for username and password to go inside manager to see war files deployed in tomcat server
 - but we did not created any tomcat users yet, so we need to create tomcat users with roles in tomcat configuration file

- see inside the "/opt/tomcat/conf/tomcat-users.xml" file
- cmd: vi /opt/tomcat/conf/tomcat-users.xml # in this file we create tomcat users with roles to give access to manager and host-manager apps, 
  - now add below lines inside <tomcat-users> </tomcat-users> tag
  <role rolename="manager-gui" />
  <role rolename="manager-script" />
  <role rolename="manager-jmx" />
  <role rolename="manager-status" />
  <user username="admin" password="admin" roles="manager-gui, manager-script, manager-jmx, manager-status" />
  <user username="deployer" password="deployer" roles="manager-script" />
  <user username="tomcat" password="s3cret" roles="manager-gui" />

- giving multiple roles to admin user for full access, deployer user for script based deployment from jenkins, tomcat user for gui access only
- now save and exit the file

- now stop and start the tomcat server to reflect the changes
 - cmd: cd /opt/tomcat/bin
 - cmd: ./shutdown.sh   # stop tomcat server
 - cmd: ./startup.sh    # start tomcat server

- now relod tomcat server on browser 
 http://[tomcat-server-elastic-ip]:8080/manager/html
- now it asking for username and password
- now use admin user to login
  - username: admin
  - password: admin
- now you can see the tomcat manager app dashboard


- now the main .war file store in tomcat server location is
  - /opt/tomcat/webapps/   # this is the default location where tomcat deploys war files

########### wait


  - but we going to automate the deployment of war file from jenkins-server to tomcat-server using jenkins job created earlier

+------------------------+                               +------------------------+
|      JENKINS-SERVER    |                               |      TOMCAT-SERVER      |
|  (Main CI/CD Engine)   |                               |   (App Deployment Host) |
|                        |                               |                        |
| - Stores Tomcat creds  | <------ provides creds ------- | Manager-App Credentials |
| - Builds WAR file      |                               | (username/password)    |
| - Deploys WAR          | ------ deploy new WAR -------> | Deploys & Runs App     |
+------------------------+                               +------------------------+


- so now go to jenkins-server instance to configure jenkins job for war deployment to
- and provide tomcat-server manager app credentials in jenkins-server instance

> go to jenkins dashboard
- go to Manage Jenkins > Credentials(configure credentials) > System - global credentials (add credentials)
- click on "Add Credentials" option
- now provide below details
  - Kind: Username with password
  - Scope: Global
  - Username: admin     # tomcat manager app user created earlier in tomcat-server instance
  - Password: admin     # tomcat manager app user password created earlier in tomcat-server instance
  - ID: tomcat-deployer-credentials   # give any id name
  - Description: Tomcat-Credentials  
- now click on OK to save the credentials

> those credentials will be used in jenkins job to deploy war file to tomcat server

> now create a fresh job or modify existing jenkins job to deploy war file to tomcat server
> go to jenkins dashboard
- click on "New Item"
- enter item name: BuildAndDeployJob
- choose "maven project" option || or modify existing jenkins job
- click OK  

> I choose existing job "FirstJob" to modify for war deployment to tomcat server
- (it have already git and maven build configuration)

- now go to Post-build Actions section
  - Deploy WAR/EAR to a container:  # to deploy war file to tomcat server from jenkins
  - WAR/EAR files: target/FormFillApp.war  || or **/*.war  # path of war file generated after maven build
  - Context path: /FormFillApp  (optional cause we use default location tomcat manager)  # context path to access the app in browser
  - Containers: Tomcat 7.x Remote # choose tomcat version
    - Tomcat URL: http://[tomcat-server-elastic-ip]:8080/  # tomcat server url to deploy war file
    - Credentials: tomcat-deployer-credentials  # choose the credentials created earlier for tomcat manager app
- now save the jenkins job configuration

- nwo build job manually first time
- click on "Build Now" option
( it will copied to tomcat default webapp directory /opt/tomcat/webapps/, and deploy the war file automatically on tomcat server  )

> verify war file generated in tomcat-server location and also jenkins locatin in machines
- go inside tomcat-server instance, default location is 
  - cmd: cd /opt/tomcat/webapps/
  - cmd: ls -l
   - output: webapps.war   # war file deployed from jenkins-server to tomcat-server

> also verify in jenkins-server instance location
- go inside jenkins-server instance, jenkins job location is 
  - cmd: cd /var/lib/jenkins/workspace/BuildAndDeployJob/webapp/target
  - cmd: ls -l
   - output: webapps.war   # war file generated after maven build   

# now its automated deployment of war file from jenkins-server to tomcat-server using jenkins job
- but there is a problem we use only one machine for deployment like tomcat-server, in real time scenario we have multiple tomcat servers for deployment (like tomcat-server-1, tomcat-server-2, tomcat-server-3 etc) for load balancing and high availability
- so we use Docker which deploy multiple tomcat containers in single machine (jenkins-server) for deployment purpose
- and we configure jenkins job to deploy war file to multiple tomcat containers running in jenkins-server instance

- we use professional manner
- so we create instance for docker-server instance
- and deploy war file to multiple tomcat containers running in docker-server instance from jenkins-server instance using jenkins job
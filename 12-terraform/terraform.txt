# ------------ Terrform ------------ #

âœ… What is Terraform?
- Terraform is a Infrastructure as Code (IaC) tool used to create, manage, and automate AWS resource using code 
  instead of clicking manually in the AWS console.

- we use file xtension ".tf" which define the terraform file, to build aws resources.

ðŸŸ© Everything is written as code ...
 - we can define : EC2, VPC, S3, RDS, LOAD BALANCER, IAM all services can use in configuration file

 - create one terraform file > use again for dev, test, production.
 
 > Automate full AWS setup
  - we can deploy full architecture (EC2 + VPC + S3 + LB) in a few second.

 > Multi Cloud  > same tool work with 
  - AWS 
  - AZURE
  - GOOGLE CLOUD 



âœ… Architecture Diagram â€” Terraform Managing AWS

                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚       Developers         â”‚
                   â”‚   (Write .tf files)      â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚  Terraform CLI     â”‚
                     â”‚ (init, plan, apply)â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Terraform Core     â”‚
                    â”‚  (Reads & processes  â”‚
                    â”‚   configuration)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚   Provider Plugins (AWS)   â”‚
                 â”‚  e.g. aws_vpc, aws_ec2,    â”‚
                 â”‚       aws_s3, aws_rds      â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚         AWS API            â”‚
                 â”‚ (Terraform talks directly  â”‚
                 â”‚    with AWS services)      â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                      AWS Cloud                        â”‚
      â”‚                                                      â”‚
      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚   â”‚   VPC       â”‚   â”‚   EC2         â”‚   â”‚   S3     â”‚ â”‚
      â”‚   â”‚ (Subnets)   â”‚   â”‚ (Servers)     â”‚   â”‚ (Storage)â”‚ â”‚
      â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â”‚                                                      â”‚
      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚   â”‚ RDS DB      â”‚   â”‚ LoadBalancer â”‚   â”‚ IAM Roles â”‚ â”‚
      â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â”‚                                                      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ðŸŸ¦ Flow of Terraform Commands

terraform init  = download provider plugins (AWS)
terraform plan  = show what changes will happen 
terraform apply = create/update aws services 
terraform destroy =  remove all resources 


ðŸŸ© Detailed : Terraform Project Structure

terraform-project/
â”‚
â”œâ”€â”€ main.tf          â†’ Provider + resources
â”œâ”€â”€ variables.tf     â†’ All input variables
â”œâ”€â”€ outputs.tf       â†’ Output values like IPs
â”œâ”€â”€ modules/         â†’ Reusable modules
â”‚     â”œâ”€â”€ vpc/
â”‚     â”œâ”€â”€ ec2/
â”‚     â””â”€â”€ rds/
â””â”€â”€ terraform.tfstateâ†’ State file (tracks AWS resources)



ðŸŸ© Terraform Module Architecture (Recommended Pattern)

root/
â”‚
â”œâ”€â”€ main.tf
â”œâ”€â”€ variables.tf
â”œâ”€â”€ outputs.tf
â”œâ”€â”€ modules/
â”‚    â”œâ”€â”€ vpc/
â”‚    â”‚    â”œâ”€â”€ main.tf
â”‚    â”‚    â”œâ”€â”€ variables.tf
â”‚    â”‚    â””â”€â”€ outputs.tf
â”‚    â”‚
â”‚    â”œâ”€â”€ ec2/
â”‚    â”‚    â”œâ”€â”€ main.tf
â”‚    â”‚    â”œâ”€â”€ variables.tf
â”‚    â”‚    â””â”€â”€ outputs.tf
â”‚    â”‚
â”‚    â””â”€â”€ rds/
â”‚         â”œâ”€â”€ main.tf
â”‚         â”œâ”€â”€ variables.tf
â”‚         â””â”€â”€ outputs.tf




ðŸŸ¦ State Management (Very Important)

                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚   terraform.tfstate     â”‚
                   â”‚  (Maps real AWS â†’ code) â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Local State or Remote S3 Backendâ”‚
            â”‚ + DynamoDB (state locking)      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ðŸŸ¦ How Terraform Interacts with AWS for Each Service

Terraform Code  â†’  AWS Provider  â†’  AWS Service

aws_vpc          â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  VPC API              â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Creates VPC + Subnets + IGW + Routes
aws_subnet       â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Subnet API           â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Creates Public/Private Subnets
aws_internet_gateway â”€â”€â”€â”€â”€â–º IGW API               â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Internet Connectivity
aws_route_table  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Route Table API      â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Adds Routes (IGW / NAT)

aws_instance     â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  EC2 API              â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Launch EC2 machines
aws_security_group â”€â”€â”€â”€â”€â”€â”€â–º  SG API               â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Creates security rules

aws_lb           â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  ELB API              â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create ALB/NLB Load Balancers
aws_lb_target_group â”€â”€â”€â”€â”€â–º  Target Group API      â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Register EC2 Targets

aws_s3_bucket    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  S3 API               â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create S3 Buckets
aws_s3_bucket_policy â”€â”€â”€â”€â”€â–º S3 Policy API         â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Manage bucket permissions

aws_rds_instance â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  RDS API              â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Creates MySQL/Postgres DB
aws_db_subnet_group â”€â”€â”€â”€â”€â–º  RDS Subnet API        â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  DB Subnets

aws_iam_role     â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  IAM API              â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create IAM Role
aws_iam_policy   â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  IAM Policy API       â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Attach JSON Policies

aws_lambda_function â”€â”€â”€â”€â”€â–º Lambda API             â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create Lambda Function

aws_cloudwatch_log_group â”€â–º CloudWatch API        â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create Log Groups

aws_route53_record â”€â”€â”€â”€â”€â”€â”€â–º Route53 API           â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create DNS Records

aws_eks_cluster  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º EKS API               â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create Kubernetes Cluster

aws_sqs_queue    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º AWS SQS API           â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create Queues
aws_sns_topic    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º AWS SNS API           â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Push Notifications

aws_dynamodb_table â”€â”€â”€â”€â”€â”€â”€â–º DynamoDB API          â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Create NoSQL Tables



# Install Terraform in windows 
cmd: npm install terraform     # it willdow or 


# Go to "terraform.io" official site 
- search for "windows"   > take binary download "386..." tar file 

- extract terrafrom file only on "C://" drive with "terraform" name 

- if terraform install then verify by there version 
cmd: terraform -version 

- see terraform cmd list 
cmd: terraform 


# Setting up terraform path for, to access terraform related cmd anywhere in the system.

- AWS cli tool  (download)
- it will help to manage AWS Infrastructure through cli. its kind of agent( aws cli)

> download aws cli to (msi file)

# setup env aws path 
- C:\Program Files\Amazon\AWSCLIV2
- in system vaiable add this into the path 
- then verify aws --version anywhere 

- to verify aws is installed or not 
- to go command prompt tool 
cmd: aws --version

result it cli tool downloaded then it shows aws version 

#####################################################


# Create IAM user for terraform to authenticate any user (user/role)

- IAM service 
- user  (create)
Specify user details
- user name: terraform-user
- next 
Set permissions
- Attach policies directly ðŸ’¹
- Permissions policies : AdministratorAccess
- next 
- create user 

> Go inside created user 
> Security credentials 
  - Access keys (0)  : create access key  ðŸ’¹
    - use case 
      - Command Line Interface (CLI)
      - next 
      - create access key
      - download .csv file and   
      - Done 


# AWS cli,  every time create new file it need "Access key" and "Secret Key", it is messy or headache.
  so instead of this headache, we setup Environment Variables       

  - go to Environment vaiable
    - system variable 
    - create new

    variable name: AWS_ACCESS_KEY_ID
    variable value: AKIA4UCHAAQPZUMRASVE

  - for secret access key add (new variable)  
    variable name: AWS_SECRET_ACCESS_KEY
    vaiable value : 13G2qKlVD1Vjf3+ptmt8u//QUb5NLoxkm6wV84x7

  - we can add aws region in env so by default it will start from that region 
    variable name: AWS_DEFAULT_REGION
    variable value: us-east-1

  - apply + okay     

# Open command prompt 
cmd: echo %AWS_ACCESS_KEY_ID%

cmd: echo %AWS_SECRET_ACCESS_KEY%

cmd: echo %AWS_DEFAULT_REGION%

> for this env setup, it means if I launch any Instance without mentioning region, by default launch in North Virginia region 

- cause we setup ENV variable (system varible)
- so by default when open aws instance if shows only default Virginia region. 


# Make a folder for EC2 instance 
cmd; mkdir EC2_Instance 

- Recommended file name for terraform, is "main.tf"

- create a main.tf file for terraform inside folder 
cmd: touch main.tf 

> Inside this file, to launch an instance whatever required things are like... 
 
  - we have to give 
    - region name 
    - instance name 
    - instance ami id 
    - key-pair
    - security-group 
    - instance-type 
    - hard disk details 

    so, everything we have to give 

# Keep ready key-pair in instance (.pem file)
name: k8sKey.pem 

- a key pair in aws is just a way to authenticate to ec2 instance 

- use a single aws key pair for multiple instances, regardless of which ami (ubuntu, amazon linux, windows) etc. 

- a public key stored by aws 
- a private key (.pem) file that we have downloaded
- and use to connect (ssh for linux, rdp) for windows password description

- without key-pair (.pem) file you cont connect to instance using that key 
- key-pair is region Specific. 


# Write / create instance in "main.tf" file 

ðŸ’¹ Initialize Terraform
  Downloads AWS provider & sets up working directory:
  
cmd: terraform init 
    - it is a first cmd, you run in any new terraform project or when you add new provides/modules 
    - in order to execute that file, regulated dependencies are downloaded, will be installed automatically.
    - means required plugins installed (.terraform)
    - this runs only once in that folder, in folder you will see .terraform file 

    .terraform
    .terraform.lock.hcl
    in that folder where initialize terraform. 

ðŸ’¹ Validate Terraform Code 
  - Check systax errors 

cmd: terraform validate
      

ðŸ’¹ Format terraform code 
   - makes ".tf" file look cleen and correct
cmd: terraform fmt         # fmt means format 


ðŸ’¹ Generate Execution Plan 
   - Shows what Terraform will create/update/delete 

cmd: terraform plan 


ðŸ’¹ Apply terraform scripts 
  - Actually creates resource (EC2, VPC, etc...)

cmd: terraform apply 
- terraform will ask 
  - Enter a value: yes 

or we can skip this above 
cmd: terraform apply -auto-approve         # this will not ask confirmation to yes 



ðŸ’¹ Destroy Resouces 
  - Delete everything created by terraform: 

cmd: terraform destroy -auto-approve 


ðŸ’¹ Terraform state commands 
  - show current state 

cmd: terraform state list


ðŸ’¹ Show details of resource 
cmd: terraform state show aws_instance.myInstance

ðŸ’¹ display the current state of our Infrastructure
cmd: terraform show

ðŸ’¹ Terraform output commands 
- if define outputs 
cmd: terraform output 


ðŸ’¹ terraform version 
- check version 
cmd: terraform version 

ðŸ’¹ terraform providers 
- show installed providers 
cmd: terraform providers

ðŸ’¹ terraform clean up (optional)
- removes downloaded plugins 
cmd: terraform init -migrate-state 



âœ… When Updating â€” What Causes Conflict and What Does NOT

âœ… 1. Things you can update safely (NO conflict, NO recreate)
> Safe changes 
- name tag 
- others tags 
- User-data (only in AWS console) > no creae 
- IAM role  attachment/detachment
- security groups (in most cases) 
- ElasticIP association
- start/stop instance 
- add/remove EBS volume
- Modify EBS volume
- change shutdown behaviour
- update instance metadata options 

âŒ 2. Things that WILL cause EC2 to be recreated (destroy + create)
> these are dangerous while updating in Terraform
> If we change this, Terraform will destroy the instance and create a new one.

> Changing these RE-CREATE:
- AMI  = changing AMI, create new EC2 
- subnet ID 
- vpc ID 
- availability zones 
- private IP (if not manually assigned)
- root volume type change (gp3  -  io1) sometimes
- changing "associate_public_id_address"
- changing network interface settings 
- deelete or rename Terraform resource (cause replacement)
- changing key-pair for EC2 

> if we change anything, terraform will recreate a brand new EC2


âœ… Create full controlled EC2 Instance 

> main.tf 

----------------   script start ----------------

// provider "aws" and region name 
provider "aws" {
  region = "us-east-1"
}

// create resource for EC2 Instance 

resource "aws_instance" "example_instance" {

  ami =  "<ami-id>"
  instance_type = "t2.small"
  key_name  = "k8sKey"
  vpc_security_group_id = ["<sg-id>"]
  

  // provide storage/volume for ec2 instance
  root_block_volume {
    volume_size = 15      // 15 GiB storage 
  }

  // AWS console name (tag name will create )
  tags = {
    Name = "FirstInstance"
  }

}


// create security group id 

resource "aws_security_group" "example_sg" {
  name = "example_security_sg"
  description = "Allow RDP and HTTP access"


  // create inbound rules to allow SSH access 

  ingress {
    from_port = 22
    to_port   = 22
    protocol  = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  // create inboud to allow traffic for everyone HTTP access (for web content)

  ingress {
    from_port  = 80
    to_port    = 80
    protocol   = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  // outboud rule to allow all traffics

  egress {
    from_port  = 0              // zero (0) means, all ports 
    to_port    = 0
    protocol   = "tcp"          // all protocols
    cidr_blocks = ["0.0.0.0/0"]  // allow traffic to all 
  }

}


// ouput the public IP of the instance 
ouput "instance_public_ip" {
  description  = "The public IP address of the EC2 instance"
  value   = aws_instance.example_instance.public_ip   // value must match with the "aws_instance" above resource
}

// output the public IP of the instance
ouput "instance_private_ip" {
  description = "the private IP address of the EC2 instance" 
  value       = aws_instance.example_instance.private_ip 
}

----------------   script end ----------------

> validate first name-convention
cmd: terraform validate 

   - if thee is anerror, so fix it otherwise it will show "Success" the configuration is valid 

> then  run plan cmd 
cmd: terraform plan 
   - yes 

> then apply or create new/update instance    
cmd: terraform apply -auto-approve 